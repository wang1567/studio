"use client";

import type { Dog, Profile, UserRole, HealthRecord, FeedingSchedule, VaccinationRecord } from '@/types';
import React, { useCallback, useEffect, useState, useRef } from 'react';
import { supabase } from '@/lib/supabaseClient';
import type { User as SupabaseUser, Session as SupabaseSession, PostgrestError, AuthApiError } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';
import { useToast } from '@/hooks/use-toast';
type DbDog = Database['public']['Views']['dogs_for_adoption_view']['Row'];
type DbProfile = Database['public']['Tables']['profiles']['Row'];


interface PawsConnectContextType {
  dogsToSwipe: Dog[];
  likedDogs: Dog[];
  seenDogIds: Set<string>;
  likeDog: (dogId: string) => Promise<void>;
  passDog: (dogId:string) => void;
  getDogById: (dogId: string) => Dog | undefined;
  isLoadingDogs: boolean;
  loadDogsWhenNeeded: () => Promise<void>;
  getLikedDogsCount: () => Promise<number>;

  user: SupabaseUser | null;
  profile: Profile | null;
  session: SupabaseSession | null;
  isLoadingAuth: boolean;
  isUpdatingProfile: boolean;
  login: (email: string, password: string) => Promise<{ session: SupabaseSession | null; error: string | null }>;
  signUp: (email: string, password: string, role: UserRole, fullName?: string | null) => Promise<{ user: SupabaseUser | null; error: string | null }>;
  logout: () => Promise<{ error: string | null }>;
  updateProfile: (updates: { fullName?: string | null; avatarUrl?: string | null }) => Promise<{ success: boolean; error?: string | null; updatedProfile?: Profile | null }>;
  deleteAccount: () => Promise<{ error: string | null }>;
  sendPasswordResetEmail: (email: string) => Promise<{ error: string | null }>;
  resendVerificationEmail: (email: string) => Promise<{ error: string | null }>;
  updateUserEmail: (newEmail: string) => Promise<{ error: string | null }>;
}

const PawsConnectContext = React.createContext<PawsConnectContextType | undefined>(undefined);

const mapDbDogToDogType = (dbViewDog: DbDog): Dog => {
  const defaultHealthRecord: HealthRecord = { lastCheckup: '', conditions: [], notes: 'Êú™Êèê‰æõË®òÈåÑ' };
  const defaultFeedingSchedule: FeedingSchedule = { foodType: 'Êú™ÊåáÂÆö', timesPerDay: 0, portionSize: 'Êú™ÊåáÂÆö', notes: 'Êú™Êèê‰æõË®òÈåÑ' };
  
  const photos = Array.isArray(dbViewDog.photos) ? dbViewDog.photos.filter((p): p is string => typeof p === 'string') : [];
  const personalityTraits = Array.isArray(dbViewDog.personality_traits) ? dbViewDog.personality_traits.filter((p): p is string => typeof p === 'string') : [];
  
  const healthRecordsData = (dbViewDog.health_records as unknown) as HealthRecord | null;
  const feedingScheduleData = (dbViewDog.feeding_schedule as unknown) as FeedingSchedule | null;

  // Normalize vaccination records coming from JSON aggregate
  const vaccinationRecordsRaw = (dbViewDog.vaccination_records as unknown) as any[] | null;
  const vaccinationRecords: VaccinationRecord[] = Array.isArray(vaccinationRecordsRaw)
    ? vaccinationRecordsRaw.map((vr: any) => ({
        vaccineName: typeof vr?.vaccine_name === 'string' ? vr.vaccine_name : (typeof vr?.vaccineName === 'string' ? vr.vaccineName : 'Êú™ÊåáÂÆöÁñ´Ëãó'),
        dateAdministered: typeof vr?.date === 'string' ? vr.date : (typeof vr?.dateAdministered === 'string' ? vr.dateAdministered : ''),
        nextDueDate: typeof vr?.next_due_date === 'string' ? vr.next_due_date : (typeof vr?.nextDueDate === 'string' ? vr.nextDueDate : undefined),
      }))
    : [];

  const meaningfulConditions = healthRecordsData?.conditions?.filter(
    c => c && c.trim() && c.trim().toLowerCase() !== 'none' && c.trim() !== 'ÁÑ°'
  ) || [];
  
  return {
    id: dbViewDog.id,
    name: dbViewDog.name || 'Êú™ÂëΩÂêçÁãóÁãó',
    breed: dbViewDog.breed || 'Êú™Áü•ÂìÅÁ®Æ',
    age: typeof dbViewDog.age === 'number' ? dbViewDog.age : 0,
    gender: dbViewDog.gender === 'Male' || dbViewDog.gender === 'Female' || dbViewDog.gender === 'Unknown' ? dbViewDog.gender : 'Unknown',
    photos: photos.length > 0 ? photos : ['https://placehold.co/600x400.png?text=' + encodeURIComponent(dbViewDog.name || 'Dog')],
    description: dbViewDog.description || 'Êö´ÁÑ°ÊèèËø∞„ÄÇ',
    healthRecords: {
      lastCheckup: healthRecordsData?.lastCheckup || defaultHealthRecord.lastCheckup,
      conditions: meaningfulConditions,
      notes: healthRecordsData?.notes || defaultHealthRecord.notes,
    },
    feedingSchedule: {
      foodType: feedingScheduleData?.foodType || defaultFeedingSchedule.foodType,
      timesPerDay: typeof feedingScheduleData?.timesPerDay === 'number' ? feedingScheduleData.timesPerDay : defaultFeedingSchedule.timesPerDay,
      portionSize: feedingScheduleData?.portionSize || defaultFeedingSchedule.portionSize,
      notes: feedingScheduleData?.notes || defaultFeedingSchedule.notes,
    },
    vaccinationRecords,
    liveStreamUrl: dbViewDog.live_stream_url || undefined,
    status: dbViewDog.status === 'Available' || dbViewDog.status === 'Pending' || dbViewDog.status === 'Adopted' ? dbViewDog.status : 'Available',
    location: dbViewDog.location || 'Êú™Áü•Âú∞Èªû',
    personalityTraits: personalityTraits.length > 0 ? personalityTraits : ['ÂÄãÊÄßÊ∫´Âíå'],
  };
};


export const PawsConnectProvider = ({ children }: { children: React.ReactNode }) => {
  const [masterDogList, setMasterDogList] = useState<Dog[]>([]);
  const [dogsToSwipe, setDogsToSwipe] = useState<Dog[]>([]);
  const [likedDogs, setLikedDogs] = useState<Dog[]>([]);
  const [seenDogIds, setSeenDogIds] = useState<Set<string>>(new Set());
  const [isLoadingDogs, setIsLoadingDogs] = useState(false);
  const [dogsLoaded, setDogsLoaded] = useState(false);
  const [likedDogsCountCache, setLikedDogsCountCache] = useState<number | null>(null);

  const [user, setUser] = useState<SupabaseUser | null>(null);
  const [session, setSession] = useState<SupabaseSession | null>(null);
  const [profile, setProfile] = useState<Profile | null>(null);
  const [isLoadingAuth, setIsLoadingAuth] = useState(true);
  const [isUpdatingProfile, setIsUpdatingProfile] = useState(false);
  const [isLiking, setIsLiking] = useState<Set<string>>(new Set());
  const { toast } = useToast();

  // Load dogs data when needed (for swipe interface)
  const loadDogsWhenNeeded = useCallback(async () => {
    if (dogsLoaded || isLoadingDogs || !user) return;
    
    setIsLoadingDogs(true);
    try {
      await loadInitialDogData(user.id);
      setDogsLoaded(true);
    } catch (error) {
      console.error('Error loading dogs when needed:', error);
    } finally {
      setIsLoadingDogs(false);
    }
  }, [dogsLoaded, isLoadingDogs, user?.id]); // Âè™‰æùË≥¥ user.id ËÄå‰∏çÊòØÊï¥ÂÄã user Áâ©‰ª∂

  const resetDogState = useCallback(() => {
    setMasterDogList([]);
    setDogsToSwipe([]);
    setLikedDogs([]);
    setDogsLoaded(false);
    setSeenDogIds(new Set());
    setIsLoadingDogs(true);
    setLikedDogsCountCache(null);
  }, []);

  // Get liked dogs count without loading full dog data
  const getLikedDogsCount = useCallback(async (): Promise<number> => {
    console.log('üîç [getLikedDogsCount] ÈñãÂßãÁç≤ÂèñÂñúÊ≠°ÁöÑÁãóÁãóÊï∏Èáè');
    
    if (!user) {
      console.log('‚ùå [getLikedDogsCount] Áî®Êà∂Êú™ÁôªÂÖ•ÔºåËøîÂõû 0');
      return 0;
    }
    
    console.log(`üë§ [getLikedDogsCount] Áî®Êà∂ID: ${user.id}`);
    
    // If dogs are already loaded, use cached data
    if (dogsLoaded && likedDogs.length > 0) {
      console.log(`‚úÖ [getLikedDogsCount] ‰ΩøÁî®Â∑≤ËºâÂÖ•ÁöÑÁãóÁãóË≥áÊñôÔºåÊï∏Èáè: ${likedDogs.length}`);
      return likedDogs.length;
    }
    
    // Use cached count if available
    if (likedDogsCountCache !== null) {
      console.log(`üíæ [getLikedDogsCount] ‰ΩøÁî®Âø´ÂèñË≥áÊñôÔºåÊï∏Èáè: ${likedDogsCountCache}`);
      return likedDogsCountCache;
    }
    
    console.log('üåê [getLikedDogsCount] ÈñãÂßãÂæûË≥áÊñôÂ∫´Áç≤ÂèñÊï∏Èáè');
    
    try {
      const { count, error } = await supabase
        .from('user_dog_interactions')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', user.id)
        .eq('liked', true);
      
      if (error) {
        console.error('‚ùå [getLikedDogsCount] Ë≥áÊñôÂ∫´Êü•Ë©¢ÈåØË™§:', error);
        return 0;
      }
      
      const result = count || 0;
      console.log(`‚úÖ [getLikedDogsCount] ÊàêÂäüÁç≤ÂèñÊï∏Èáè: ${result}`);
      setLikedDogsCountCache(result);
      console.log(`üíæ [getLikedDogsCount] Â∑≤Âø´ÂèñÊï∏Èáè: ${result}`);
      return result;
    } catch (error) {
      console.error('üí• [getLikedDogsCount] Êú™È†êÊúüÈåØË™§:', error);
      return 0;
    }
  }, [user?.id, dogsLoaded, likedDogsCountCache]); // Âè™‰æùË≥¥ÁúüÊ≠£ÊúÉÂΩ±ÈüøÁµêÊûúÁöÑËÆäÊï∏


  const fetchProfileAndSet = async (user: SupabaseUser | null) => {
    console.log('üîç [fetchProfileAndSet] ÈñãÂßãÁç≤ÂèñÂÄã‰∫∫Ë≥áÊñô');
    
    if (!user) {
      console.log('‚ùå [fetchProfileAndSet] Áî®Êà∂ÁÇ∫Á©∫ÔºåË®≠ÂÆö profile ÁÇ∫ null');
      setProfile(null);
      return;
    }

    console.log(`üë§ [fetchProfileAndSet] Áî®Êà∂ID: ${user.id}, Email: ${user.email}`);

    // ÂÖàÊ™¢Êü•Âø´Âèñ
    const cachedProfile = localStorage.getItem('pawsconnect_profile');
    if (cachedProfile) {
      try {
        const profileData = JSON.parse(cachedProfile);
        if (profileData.id === user.id) {
          console.log('üíæ [fetchProfileAndSet] ‰ΩøÁî®Âø´ÂèñÁöÑ profile Ë≥áÊñô:', profileData);
          setProfile(profileData);
          // Âú®ËÉåÊôØÊõ¥Êñ∞ profileÔºå‰ΩÜ‰∏çÈòªÂ°û UI
          console.log('üîÑ [fetchProfileAndSet] Âú®ËÉåÊôØÊõ¥Êñ∞ profile Ë≥áÊñô');
          fetchAndUpdateProfile(user);
          return;
        }
      } catch (e) {
        console.log('Âø´Âèñ profile Ë≥áÊñôÁÑ°Êïà');
      }
    }

    // Â¶ÇÊûúÊ≤íÊúâÂø´ÂèñÔºåÂâáÈÄ≤Ë°åÂÆåÊï¥ËºâÂÖ•
    await fetchAndUpdateProfile(user);
  };

  const fetchAndUpdateProfile = async (user: SupabaseUser) => {
    console.log('üåê [fetchAndUpdateProfile] ÈñãÂßãÂæûË≥áÊñôÂ∫´Áç≤ÂèñÊúÄÊñ∞ profile');
    
    try {
      const { data: profileData, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single<DbProfile>();

      if (profileError && profileError.code !== 'PGRST116') {
        console.error('‚ùå [fetchAndUpdateProfile] ËÆÄÂèñÂÄã‰∫∫Ë≥áÊñôÊôÇÁôºÁîüÈåØË™§:', profileError);
        setProfile(null);
      } else if (profileData) {
        console.log('‚úÖ [fetchAndUpdateProfile] ÊàêÂäüÁç≤Âèñ profile Ë≥áÊñô:', profileData);
        
        const newProfile = {
          id: profileData.id,
          role: profileData.role as UserRole,
          fullName: profileData.full_name,
          avatarUrl: profileData.avatar_url,
          updatedAt: profileData.updated_at,
        };
        
        console.log('üìù [fetchAndUpdateProfile] ËôïÁêÜÂæåÁöÑ profile:', newProfile);
        setProfile(newProfile);
        
        // Êõ¥Êñ∞Âø´Âèñ
        localStorage.setItem('pawsconnect_profile', JSON.stringify(newProfile));
        console.log('üíæ [fetchAndUpdateProfile] Â∑≤Êõ¥Êñ∞ localStorage Âø´Âèñ');
      } else {
        console.log('‚ö†Ô∏è [fetchAndUpdateProfile] Êú™ÊâæÂà∞ profile Ë≥áÊñôÔºåÂòóË©¶ÂâµÂª∫Êñ∞ÁöÑ profile');
        
        // ÂâµÂª∫Êñ∞ÁöÑ profile Ë®òÈåÑ
        try {
          console.log('üî® [fetchAndUpdateProfile] Ê∫ñÂÇôÂâµÂª∫ profileÔºåÁî®Êà∂Ë≥áÊñô:', {
            id: user.id,
            email: user.email,
            user_metadata: user.user_metadata
          });
          
          const profileData = {
            id: user.id,
            role: 'adopter' as const, // ‰ΩøÁî®Ê≠£Á¢∫ÁöÑ enum ÂÄº
            full_name: user.user_metadata?.full_name || user.email?.split('@')[0] || null,
            avatar_url: user.user_metadata?.avatar_url || null,
          };
          
          console.log('üìù [fetchAndUpdateProfile] Âç≥Â∞áÊèíÂÖ•ÁöÑË≥áÊñô:', profileData);
          
          const { data: newProfileData, error: createError } = await supabase
            .from('profiles')
            .insert(profileData)
            .select()
            .single<DbProfile>();

          if (createError) {
            console.error('‚ùå [fetchAndUpdateProfile] ÂâµÂª∫ profile Â§±Êïó:', {
              error: createError,
              code: createError.code,
              message: createError.message,
              details: createError.details,
              hint: createError.hint
            });
            
            // Â¶ÇÊûúÊòØÂîØ‰∏ÄÊÄßÁ¥ÑÊùüÈåØË™§ÔºåÂòóË©¶Êõ¥Êñ∞ÁèæÊúâË®òÈåÑ
            if (createError.code === '23505') {
              console.log('üîÑ [fetchAndUpdateProfile] profile Â∑≤Â≠òÂú®ÔºåÂòóË©¶Êõ¥Êñ∞');
              const { data: updateData, error: updateError } = await supabase
                .from('profiles')
                .update({
                  full_name: profileData.full_name,
                  avatar_url: profileData.avatar_url,
                  updated_at: new Date().toISOString()
                })
                .eq('id', user.id)
                .select()
                .single<DbProfile>();
                
              if (updateError) {
                console.error('‚ùå [fetchAndUpdateProfile] Êõ¥Êñ∞ profile ‰πüÂ§±Êïó:', updateError);
                setProfile(null);
                return;
              } else if (updateData) {
                console.log('‚úÖ [fetchAndUpdateProfile] ÊàêÂäüÊõ¥Êñ∞ÁèæÊúâ profile:', updateData);
                const updatedProfile = {
                  id: updateData.id,
                  role: updateData.role as UserRole,
                  fullName: updateData.full_name,
                  avatarUrl: updateData.avatar_url,
                  updatedAt: updateData.updated_at,
                };
                setProfile(updatedProfile);
                localStorage.setItem('pawsconnect_profile', JSON.stringify(updatedProfile));
                return;
              }
            }
            
            setProfile(null);
          } else if (newProfileData) {
            console.log('‚úÖ [fetchAndUpdateProfile] ÊàêÂäüÂâµÂª∫Êñ∞ÁöÑ profile:', newProfileData);
            
            const newProfile = {
              id: newProfileData.id,
              role: newProfileData.role as UserRole,
              fullName: newProfileData.full_name,
              avatarUrl: newProfileData.avatar_url,
              updatedAt: newProfileData.updated_at,
            };
            
            setProfile(newProfile);
            localStorage.setItem('pawsconnect_profile', JSON.stringify(newProfile));
            console.log('üíæ [fetchAndUpdateProfile] Êñ∞ profile Â∑≤Âø´Âèñ');
          }
        } catch (createErr) {
          console.error('üí• [fetchAndUpdateProfile] ÂâµÂª∫ profile ÊôÇÁôºÁîüÈåØË™§:', createErr);
          
          // Â¶ÇÊûúÂâµÂª∫Â§±ÊïóÔºåË®≠ÁΩÆ‰∏ÄÂÄãËá®ÊôÇÁöÑ profile
          console.log('üÜò [fetchAndUpdateProfile] ÂâµÂª∫Ëá®ÊôÇ profile ‰ª•ÈÅøÂÖçËºâÂÖ•Âç°‰Ωè');
          const tempProfile = {
            id: user.id,
            role: 'adopter' as UserRole,
            fullName: user.user_metadata?.full_name || user.email?.split('@')[0] || 'Êñ∞Áî®Êà∂',
            avatarUrl: user.user_metadata?.avatar_url || null,
            updatedAt: new Date().toISOString(),
          };
          
          setProfile(tempProfile);
          // ‰∏çÂø´ÂèñËá®ÊôÇ profileÔºå‰ª•‰æø‰∏ãÊ¨°ÈáçÊñ∞ÂòóË©¶ÂâµÂª∫
          console.log('‚ö†Ô∏è [fetchAndUpdateProfile] ‰ΩøÁî®Ëá®ÊôÇ profileÔºå‰∏ãÊ¨°ÁôªÂÖ•Â∞áÈáçÊñ∞ÂòóË©¶ÂâµÂª∫');
        }
      }
    } catch (e) {
      console.error("üí• [fetchAndUpdateProfile] ËôïÁêÜÂÄã‰∫∫Ë≥áÊñôÊôÇÁôºÁîüÊú™È†êÊúüÁöÑÈåØË™§:", e);
      setProfile(null);
    }
  };

  useEffect(() => {
    const initializeSession = async () => {
      console.log('üöÄ [initializeSession] ÈñãÂßãÂàùÂßãÂåñ session');
      
      // Á´ãÂç≥Ë®≠ÁΩÆËºâÂÖ•ÁãÄÊÖãÁÇ∫ falseÔºå‰ΩøÁî®Âø´ÂèñË≥áÊñô
      const cachedUser = localStorage.getItem('pawsconnect_user');
      const cachedProfile = localStorage.getItem('pawsconnect_profile');
      const cachedSession = localStorage.getItem('pawsconnect_session');
      
      console.log('üíæ [initializeSession] Ê™¢Êü•Âø´ÂèñË≥áÊñô:', {
        hasUser: !!cachedUser,
        hasProfile: !!cachedProfile, 
        hasSession: !!cachedSession
      });
      
      if (cachedUser && cachedProfile && cachedSession) {
        try {
          const userData = JSON.parse(cachedUser);
          const profileData = JSON.parse(cachedProfile);
          const sessionData = JSON.parse(cachedSession);
          
          console.log('üì¶ [initializeSession] Ëß£ÊûêÂø´ÂèñË≥áÊñôÊàêÂäü:', {
            userId: userData.id,
            userEmail: userData.email,
            profileId: profileData.id,
            sessionExpiresAt: sessionData.expires_at
          });
          
          // Á´ãÂç≥Ë®≠ÁΩÆÂø´ÂèñË≥áÊñôÔºå‰∏çÁ≠âÂæÖÈ©óË≠â
          setUser(userData);
          setProfile(profileData);
          setSession(sessionData);
          setIsLoadingAuth(false);
          
          // Ê™¢Êü• session ÊòØÂê¶ÈÅéÊúü
          const expiresAt = new Date(sessionData.expires_at || sessionData.expires_in);
          const now = new Date();
          
          if (expiresAt > now) {
            // Session Êú™ÈÅéÊúüÔºåÂú®ËÉåÊôØÈ©óË≠â‰∏¶Êõ¥Êñ∞
            supabase.auth.getSession().then(({ data: { session } }) => {
              if (session && session.user.id === userData.id) {
                setSession(session);
                localStorage.setItem('pawsconnect_session', JSON.stringify(session));
                // ËÉåÊôØÊõ¥Êñ∞ profile
                fetchAndUpdateProfile(session.user);
              }
            });
            
            return;
          }
        } catch (e) {
          console.log('Á∑©Â≠òÊï∏ÊìöÁÑ°ÊïàÔºåÊ∏ÖÈô§‰∏¶ÈáçÊñ∞È©óË≠â');
        }
        
        // Ê∏ÖÈô§ÁÑ°ÊïàÁ∑©Â≠ò
        localStorage.removeItem('pawsconnect_user');
        localStorage.removeItem('pawsconnect_profile');
        localStorage.removeItem('pawsconnect_session');
      }
      
      // Âü∑Ë°åÂÆåÊï¥È©óË≠â
      setIsLoadingAuth(true);
      try {
        const { data: { session: initialSession }, error } = await supabase.auth.getSession();
        
        if (error) {
           const authError = error as AuthApiError;
           if (!(authError.message === 'Invalid Refresh Token: Refresh Token Not Found' && authError.status === 400)) {
               console.error("Error getting initial session:", error);
           }
        }
        
        const currentUser = initialSession?.user ?? null;
        setSession(initialSession);
        setUser(currentUser);
        
        if (currentUser) {
          await fetchProfileAndSet(currentUser);
          // Á∑©Â≠òÁî®Êà∂Ë≥áÊñôÂíå session
          localStorage.setItem('pawsconnect_user', JSON.stringify(currentUser));
          if (initialSession) {
            localStorage.setItem('pawsconnect_session', JSON.stringify(initialSession));
          }
        } else {
          setProfile(null);
        }

      } catch (e: any) {
         console.error("Critical error during session initialization:", e);
         setSession(null);
         setUser(null);
         setProfile(null);
      } finally {
        setIsLoadingAuth(false);
      }
    };

    initializeSession();

    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (_event, newSession) => {
        const currentUser = newSession?.user ?? null;
        const previousUserId = user?.id;

        // Âè™ÊúâÂú®Áî®Êà∂ÁúüÊ≠£ÊîπËÆäÊôÇÊâçË®≠ÁΩÆËºâÂÖ•ÁãÄÊÖã
        const userChanged = currentUser?.id !== previousUserId;
        
        if (userChanged) {
          setIsLoadingAuth(true);
        }
        
        setSession(newSession);
        setUser(currentUser);
        
        try {
          if (currentUser && userChanged) {
              await fetchProfileAndSet(currentUser);
              // Á∑©Â≠òÁî®Êà∂Âíå session Ë≥áÊñô
              localStorage.setItem('pawsconnect_user', JSON.stringify(currentUser));
              if (newSession) {
                localStorage.setItem('pawsconnect_session', JSON.stringify(newSession));
              }
          } else if (!currentUser) {
              setProfile(null);
              resetDogState();
              // Ê∏ÖÈô§Á∑©Â≠ò
              localStorage.removeItem('pawsconnect_user');
              localStorage.removeItem('pawsconnect_profile');
              localStorage.removeItem('pawsconnect_session');
          }
        } catch (error) {
          console.error('Error handling auth state change:', error);
        } finally {
          // Âè™ÊúâÂú®Áî®Êà∂ËÆäÊõ¥ÊôÇÊâçÈáçÁΩÆËºâÂÖ•ÁãÄÊÖã
          if (userChanged || !currentUser) {
            setIsLoadingAuth(false);
          }
        }
      }
    );

    return () => {
      authListener.subscription.unsubscribe();
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);


 const loadInitialDogData = useCallback(async (currentUserId: string | null) => {
    setIsLoadingDogs(true);
    console.log(`üîÑ ÈñãÂßãËºâÂÖ•ÁãóÁãóË≥áÊñô - userId: ${currentUserId}`);
    
    if (!currentUserId) {
        setMasterDogList([]);
        setDogsToSwipe([]);
        setLikedDogs([]);
        setIsLoadingDogs(false);
        return;
    }

    try {
        console.log('üìù Êü•Ë©¢Â∑≤ÊåâËÆöÁöÑÁãóÁãó...');
        const likedDogsPromise = supabase
            .from('user_dog_likes')
            .select(`dogs_for_adoption_view(*)`)
            .eq('user_id', currentUserId);

        console.log('üìù Êü•Ë©¢ÊâÄÊúâÁãóÁãó...');
        const allDogsPromise = supabase
            .from('dogs_for_adoption_view')
            .select('*');

        const [likedDogsResult, allDogsResult] = await Promise.all([likedDogsPromise, allDogsPromise]);
        
        console.log('Êü•Ë©¢ÁµêÊûú:', { 
            likedDogsResult: likedDogsResult.data?.length, 
            allDogsResult: allDogsResult.data?.length 
        });

        const { data: likedDogsData, error: likedDogsError } = likedDogsResult;
        if (likedDogsError) {
            console.error("Error fetching liked dogs from Supabase:", likedDogsError);
            throw likedDogsError;
        }
        const userLikedDbDogs = (likedDogsData || [])
            .map((likeRecord: any) => likeRecord.dogs_for_adoption_view as DbDog | null)
            .filter((dog): dog is DbDog => !!dog);
        const userLikedDogs = userLikedDbDogs.map(mapDbDogToDogType);
        setLikedDogs(userLikedDogs);

        const { data: allDogsData, error: allDogsError } = allDogsResult;
        if (allDogsError) {
            console.error("‚ùå Êü•Ë©¢ÊâÄÊúâÁãóÁãóÊôÇÁôºÁîüÈåØË™§:", allDogsError);
            throw allDogsError;
        }
        const allDogs = allDogsData.map(mapDbDogToDogType);
        setMasterDogList(allDogs);
        
        console.log(`‚úÖ ËºâÂÖ•‰∫Ü ${allDogs.length} ÈöªÁãóÁãóÂà∞ masterDogList`);
        console.log('ÁãóÁãó IDs:', allDogs.map(d => ({ id: d.id, name: d.name })));

        const likedDogIdsSet = new Set(userLikedDogs.map(d => d.id));
        setSeenDogIds(likedDogIdsSet);
        
        const unseenDogs = allDogs.filter(dog => !likedDogIdsSet.has(dog.id));
        setDogsToSwipe(unseenDogs);
        
        console.log(`üìä Áµ±Ë®à: Á∏ΩÂÖ±${allDogs.length}ÈöªÁãóÁãóÔºåÂ∑≤ÊåâËÆö${userLikedDogs.length}ÈöªÔºåÂæÖÊªëÂç°${unseenDogs.length}Èöª`);

    } catch (error) {
        console.error("Unhandled error during dog data fetch:", error);
        setMasterDogList([]);
        setDogsToSwipe([]);
        setLikedDogs([]);
        toast({
            title: "Ë≥áÊñôËºâÂÖ•Â§±Êïó",
            description: "ÁÑ°Ê≥ïËºâÂÖ•ÁãóÁãóË≥áÊñôÔºåË´ãÁ®çÂæåÈáçÊñ∞Êï¥ÁêÜ„ÄÇ",
            variant: "destructive",
        });
    } finally {
        setIsLoadingDogs(false);
    }
}, [toast]);


  // Remove automatic dog loading when user logs in
  // Dogs will be loaded on-demand when needed for swipe interface

  useEffect(() => {
    if (!isLoadingDogs) {
      const dogsForSwiping = masterDogList.filter(dog => !seenDogIds.has(dog.id));
      setDogsToSwipe(dogsForSwiping);
    }
  }, [seenDogIds, masterDogList, isLoadingDogs]);


  const likeDog = async (dogId: string) => {
    console.log(`üêï ÈñãÂßãÊåâËÆöÊµÅÁ®ã - dogId: ${dogId}, userId: ${user?.id}`);
    
    if (isLiking.has(dogId)) {
      console.log(`‚ö†Ô∏è ÁãóÁãó ${dogId} Ê≠£Âú®ËôïÁêÜ‰∏≠ÔºåË∑≥ÈÅéÈáçË§áÊåâËÆö`);
      return;
    }

    if (!user) {
      console.log("‚ùå Áî®Êà∂Êú™ÁôªÂÖ•");
      toast({
        variant: "destructive",
        title: "ÈúÄË¶ÅÁôªÂÖ•",
        description: "Ë´ãÂÖàÁôªÂÖ•ÊâçËÉΩÊåâËÆöÁãóÁãóÔºÅ",
      });
      return;
    }

    const dog = masterDogList.find(d => d.id === dogId);
    if (!dog) {
      console.log(`‚ùå Êâæ‰∏çÂà∞ÁãóÁãó ${dogId} Âú® masterDogList ‰∏≠`);
      return;
    }

    console.log(`‚úÖ ÊâæÂà∞ÁãóÁãó: ${dog.name} (${dogId})`);

    try {
      setIsLiking(prev => new Set(prev).add(dogId));
      passDog(dogId); 

      console.log(`üìù Ê∫ñÂÇôÊèíÂÖ•Ë≥áÊñôÂ∫´: user_id=${user.id}, dog_id=${dogId}`);
      
      // Ê™¢Êü•ÁãóÁãóÊòØÂê¶Âú®‰∏çÂêåÁöÑË≥áÊñôË°®‰∏≠Â≠òÂú®
      console.log('üîç ÈñãÂßãÊ™¢Êü•ÁãóÁãóÂú®ÂêÑË≥áÊñôË°®‰∏≠ÁöÑÂ≠òÂú®ÊÄß...');
      
      // Ê™¢Êü• pets Ë≥áÊñôË°®ÁöÑË©≥Á¥∞Ë≥áË®ä
      const { data: petExists, error: petCheckError } = await supabase
        .from('pets')
        .select('id, name, created_at')
        .eq('id', dogId);
      
      console.log('üîç Ê™¢Êü• pets Ë≥áÊñôË°®:', { petExists, petCheckError });
      console.log('Âú® pets Ë≥áÊñôË°®‰∏≠ÊâæÂà∞ÁöÑÊï∏Èáè:', petExists ? petExists.length : 0);
      
      // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåÊ™¢Êü• pets Ë≥áÊñôË°®‰∏≠ÁöÑÊâÄÊúâË®òÈåÑ
      if (!petExists || petExists.length === 0) {
        const { data: allPets, error: allPetsError } = await supabase
          .from('pets')
          .select('id, name')
          .limit(10);
        
        console.log('üîç pets Ë≥áÊñôË°®‰∏≠ÁöÑÊâÄÊúâÂØµÁâ©ÔºàÂâç10Á≠ÜÔºâ:', { allPets, allPetsError });
        console.log('pets Ë≥áÊñôË°®Á∏ΩË®òÈåÑÊï∏:', allPets ? allPets.length : 0);
      }
      
      // Ê™¢Êü• dogs_for_adoption_view Ë¶ñÂúñÔºàÊàëÂÄëÁü•ÈÅìÁãóÁãóÂú®ÈÄôË£°Ôºâ
      const { data: viewExists, error: viewCheckError } = await supabase
        .from('dogs_for_adoption_view')
        .select('id')
        .eq('id', dogId);
        
      console.log('üîç Ê™¢Êü• dogs_for_adoption_view:', { viewExists, viewCheckError });
      console.log('Âú® dogs_for_adoption_view ‰∏≠ÊâæÂà∞ÁöÑÊï∏Èáè:', viewExists ? viewExists.length : 0);
      
      // Êó¢ÁÑ∂ÁãóÁãóÂ≠òÂú®Êñº view ‰∏≠ÔºåÊàëÂÄëÁπºÁ∫åÈÄ≤Ë°å
      if (viewCheckError) {
        console.log('‚ö†Ô∏è Êü•Ë©¢ view ÊôÇÁôºÁîüÈåØË™§:', viewCheckError.message);
        toast({
          variant: "destructive",
          title: "ÊåâËÆöÂ§±Êïó",
          description: "ÁÑ°Ê≥ïÈ©óË≠âÂØµÁâ©Ë≥áÊñô",
        });
        return;
      } else if (!viewExists || viewExists.length === 0) {
        console.log('‚ö†Ô∏è ÁãóÁãó‰∏çÂ≠òÂú®Êñº dogs_for_adoption_view ‰∏≠ÔºàÈÄô‰∏çÊáâË©≤ÁôºÁîüÔºâ');
        toast({
          variant: "destructive",
          title: "ÊåâËÆöÂ§±Êïó",
          description: "Ê≠§ÂØµÁâ©Ë≥áÊñôÁï∞Â∏∏ÔºåÁÑ°Ê≥ïÊåâËÆö",
        });
        return;
      } else {
        console.log('‚úÖ ÁãóÁãóÁ¢∫ÂØ¶Â≠òÂú®Êñº dogs_for_adoption_view ‰∏≠ÔºåÁπºÁ∫åÊèíÂÖ•ÊµÅÁ®ã');
        console.log('‚ö†Ô∏è Ê≥®ÊÑèÔºöÁãóÁãóÂú® view ‰∏≠Â≠òÂú®‰ΩÜÂú® pets Ë°®‰∏≠‰∏çÂ≠òÂú®ÔºåÂèØËÉΩÊúâË≥áÊñôÂêåÊ≠•ÂïèÈ°å');
      }
      
      const insertData = { 
        user_id: user.id, 
        dog_id: dogId,
        liked_at: new Date().toISOString()
      };
      
      console.log('ÊèíÂÖ•Ë≥áÊñô:', insertData);
      console.log('üîÑ ÈñãÂßãÂü∑Ë°åË≥áÊñôÂ∫´ÊèíÂÖ•Êìç‰Ωú...');
      console.log('ÁõÆÊ®ôË≥áÊñôË°®: user_dog_likes');
      console.log('Áï∂ÂâçÁî®Êà∂Ë∫´‰ªΩ:', { userId: user.id, userEmail: user.email });

      // ÂÖàÂòóË©¶Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÂ≠òÂú®Ë©≤Ë®òÈåÑ
      const { data: existingLike, error: checkError } = await supabase
        .from('user_dog_likes')
        .select('*')
        .eq('user_id', user.id)
        .eq('dog_id', dogId);

      console.log('üîç Ê™¢Êü•ÁèæÊúâÊåâËÆöË®òÈåÑ:', { existingLike, checkError });

      if (checkError) {
        console.log('‚ö†Ô∏è Ê™¢Êü•ÁèæÊúâË®òÈåÑÊôÇÁôºÁîüÈåØË™§:', checkError.message);
      } else if (existingLike && existingLike.length > 0) {
        console.log('‚úÖ Áî®Êà∂Â∑≤Á∂ìÊåâËÆöÈÅéÊ≠§ÁãóÁãóÔºåË∑≥ÈÅéÊèíÂÖ•');
        return;
      }

      // Áõ¥Êé•ÂòóË©¶ÊèíÂÖ•Ë≥áÊñô
      console.log('üöÄ ÂòóË©¶Áõ¥Êé•ÊèíÂÖ•Ë≥áÊñôÂà∞ user_dog_likes...');
      const { data, error: insertError } = await supabase
        .from('user_dog_likes')
        .insert(insertData)
        .select();
      
      console.log('‚úÖ Ë≥áÊñôÂ∫´Êìç‰ΩúÂÆåÊàê');
      console.log('ÊèíÂÖ•ÁµêÊûú:', { data, error: insertError });
      console.log('ÊèíÂÖ•ÁöÑË≥áÊñôÁ≠ÜÊï∏:', data ? data.length : 0);
      
      // Ë©≥Á¥∞ÈåØË™§Ë≥áË®ä
      if (insertError) {
        console.log('üö® Ë©≥Á¥∞ÈåØË™§Ë≥áË®ä:');
        console.log('ÈåØË™§‰ª£Á¢º:', insertError.code);
        console.log('ÈåØË™§Ë®äÊÅØ:', insertError.message);
        console.log('ÈåØË™§Ë©≥ÊÉÖ:', insertError.details);
        console.log('ÈåØË™§ÊèêÁ§∫:', insertError.hint);
        
        // ËôïÁêÜ‰∏çÂêåÈ°ûÂûãÁöÑÈåØË™§
        if (insertError.code === '23505') {
          console.log(`‚ö†Ô∏è ÈáçË§áÊåâËÆö - Áî®Êà∂ ${user.id} Â∑≤Á∂ìÂñúÊ≠°ÁãóÁãó ${dogId}`);
        } else {
            console.error("‚ùå Ë≥áÊñôÂ∫´ÊèíÂÖ•ÈåØË™§:", insertError);
            toast({
              variant: "destructive",
              title: "ÊåâËÆöÂ§±Êïó",
              description: `ÁÑ°Ê≥ïÂÑ≤Â≠òÊÇ®ÁöÑÈÅ∏Êìá: ${insertError.message}`,
            });
            setSeenDogIds(prev => {
              const newSet = new Set(prev);
              newSet.delete(dogId);
              return newSet;
            });
            return; 
        }
      } else {
        console.log(`‚úÖ ÊàêÂäüÊèíÂÖ•Ë≥áÊñôÂ∫´ - ÁãóÁãó ${dogId} Â∑≤Ë¢´Áî®Êà∂ ${user.id} ÊåâËÆö`);
      }

      setLikedDogs(prevLikedDogs => {
        if (!prevLikedDogs.some(d => d.id === dog.id)) {
          const newLikedDogs = [...prevLikedDogs, dog];
          // Update cache when successfully liking a dog
          setLikedDogsCountCache(newLikedDogs.length);
          return newLikedDogs;
        }
        return prevLikedDogs;
      });

    } catch (error) {
        console.error("An unexpected error occurred during the like operation:", error);
        toast({
          variant: "destructive",
          title: "ÁôºÁîüÊú™È†êÊúüÁöÑÈåØË™§",
          description: "ÊåâËÆöÊôÇÁôºÁîüÂïèÈ°åÔºåÊÇ®ÁöÑÊìç‰ΩúÂ∑≤Ë¢´Âæ©Âéü„ÄÇ",
        });
    } finally {
      setIsLiking(prev => {
        const newSet = new Set(prev);
        newSet.delete(dogId);
        return newSet;
      });
    }
  };

  const passDog = (dogId: string) => {
    setSeenDogIds(prevSeenDogIds => new Set(prevSeenDogIds).add(dogId));
  };
  
  const getDogById = (dogId: string): Dog | undefined => {
    return masterDogList.find(dog => dog.id === dogId) || likedDogs.find(dog => dog.id === dogId);
  };

  const login = async (email: string, password: string): Promise<{ session: SupabaseSession | null; error: string | null }> => {
    setIsLoadingAuth(true);
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    
    if (error) {
      setIsLoadingAuth(false);
      return { session: null, error: error.message || 'ÁôªÂÖ•Â§±Êïó„ÄÇË´ãÊ™¢Êü•ÊÇ®ÁöÑÂ∏≥ËôüÂØÜÁ¢º„ÄÇ' };
    }

    // Ê™¢Êü•ÈõªÂ≠êÈÉµ‰ª∂ÊòØÂê¶Â∑≤È©óË≠â
    if (data.user && !data.user.email_confirmed_at) {
      setIsLoadingAuth(false);
      return { 
        session: null, 
        error: 'Ë´ãÂÖàÈ©óË≠âÊÇ®ÁöÑÈõªÂ≠êÈÉµ‰ª∂Âú∞ÂùÄ„ÄÇÊ™¢Êü•ÊÇ®ÁöÑ‰ø°ÁÆ±ÔºàÂåÖÂê´ÂûÉÂúæÈÉµ‰ª∂Ë≥áÊñôÂ§æÔºâ‰∏¶ÈªûÊìäÈ©óË≠âÈÄ£Áµê„ÄÇ' 
      };
    }
    
    return { session: data.session, error: null };
  };

  const signUp = async (email: string, password: string, role: UserRole, fullName?: string | null): Promise<{ user: SupabaseUser | null; error: string | null }> => {
    setIsLoadingAuth(true);
    
    // Ë®ªÂÜäÊôÇË¶ÅÊ±ÇÈõªÂ≠êÈÉµ‰ª∂È©óË≠â
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${window.location.origin}/auth/callback`,
        data: {
          role,
          full_name: fullName || email.split('@')[0],
        }
      }
    });

    if (authError) {
      setIsLoadingAuth(false);
      console.error('Ë®ªÂÜäÈåØË™§:', authError);
      return { user: null, error: authError.message || 'Ë®ªÂÜäÂ§±Êïó„ÄÇË´ãÁ®çÂæåÂÜçË©¶„ÄÇ' };
    }
    
    if (!authData.user) {
      setIsLoadingAuth(false);
      return { user: null, error: 'Ë®ªÂÜäÊàêÂäüÔºå‰ΩÜÊú™ÂèñÂæó‰ΩøÁî®ËÄÖË≥áË®ä„ÄÇ' };
    }

    console.log('Ë®ªÂÜäÊàêÂäüÔºåÁî®Êà∂Ë≥áÊñô:', authData.user);
    console.log('ÈõªÂ≠êÈÉµ‰ª∂Á¢∫Ë™çÁãÄÊÖã:', authData.user.email_confirmed_at ? 'Â∑≤Á¢∫Ë™ç' : 'Êú™Á¢∫Ë™ç');

    // Â¶ÇÊûúÁî®Êà∂Â∑≤Á¢∫Ë™çÈÉµ‰ª∂ÔºåÂâáÂª∫Á´ãÂÄã‰∫∫Ë≥áÊñô
    if (authData.user.email_confirmed_at) {
      await createUserProfile(authData.user, role, fullName);
    }
    
    setIsLoadingAuth(false);
    return { user: authData.user, error: null };
  };

  // Â∞áÂª∫Á´ãÂÄã‰∫∫Ë≥áÊñôÁöÑÈÇèËºØÂàÜÈõ¢ÊàêÁç®Á´ãÂáΩÊï∏
  const createUserProfile = async (user: SupabaseUser, role: UserRole, fullName?: string | null) => {
    const getAvatarText = () => {
        if (fullName) {
            const name = fullName.trim();
            // Check for CJK characters
            const cjkRegex = /[\u4e00-\u9fa5]/;
            if (cjkRegex.test(name)) {
                return name.length > 2 ? name.substring(name.length - 2) : name;
            }
        }
        return user.email?.split('@')[0] || 'User';
    };
    
    const { error: profileError } = await supabase.from('profiles').insert({
      id: user.id,
      role,
      full_name: fullName || user.email?.split('@')[0] || 'User',
      avatar_url: `https://placehold.co/100x100.png?text=${encodeURIComponent(getAvatarText())}`,
      updated_at: new Date().toISOString(),
    });

    if (profileError) {
      console.error('Âª∫Á´ãÂÄã‰∫∫Ë≥áÊñôÊôÇÁôºÁîüÈåØË™§:', profileError);
      throw new Error('Âª∫Á´ãÂÄã‰∫∫Ë≥áÊñôÂ§±Êïó: ' + profileError.message);
    }
  };

  const logout = async (): Promise<{ error: string | null }> => {
    setIsLoadingAuth(true);
    
    // Ê∏ÖÈô§Êú¨Âú∞Á∑©Â≠ò
    localStorage.removeItem('pawsconnect_user');
    localStorage.removeItem('pawsconnect_profile');
    localStorage.removeItem('pawsconnect_session');
    
    const { error } = await supabase.auth.signOut();
    if (error) {
      setIsLoadingAuth(false);
      return { error: error.message || 'ÁôªÂá∫ÊôÇÁôºÁîüÈåØË™§„ÄÇ' };
    }
    return { error: null };
  };

  const updateProfile = async (updates: { fullName?: string | null; avatarUrl?: string | null }): Promise<{ success: boolean; error?: string | null; updatedProfile?: Profile | null }> => {
    if (!user) {
      return { success: false, error: "‰ΩøÁî®ËÄÖÊú™ÁôªÂÖ•„ÄÇ" };
    }
    setIsUpdatingProfile(true);
    try {
      const profileUpsertData: Partial<DbProfile> & { id: string } = {
        id: user.id,
        updated_at: new Date().toISOString(),
        role: profile?.role || 'adopter', // Provide a default role if needed
      };
      if (updates.fullName !== undefined) {
        profileUpsertData.full_name = updates.fullName;
      }
      if (updates.avatarUrl !== undefined) {
        profileUpsertData.avatar_url = updates.avatarUrl;
      }

      const { data, error } = await supabase
        .from('profiles')
        .upsert(profileUpsertData)
        .select()
        .single<DbProfile>();

      if (error) throw error;

      if (data) {
        const newProfile: Profile = {
          id: data.id,
          role: data.role as UserRole,
          fullName: data.full_name,
          avatarUrl: data.avatar_url,
          updatedAt: data.updated_at,
        };
        setProfile(newProfile); 
        return { success: true, updatedProfile: newProfile };
      }
      return { success: false, error: "Êõ¥Êñ∞ÂÄã‰∫∫Ë≥áÊñôÂ§±ÊïóÔºåÊú™Êî∂Âà∞ÂõûÂÇ≥Ë≥áÊñô„ÄÇ" };
    } catch (e: unknown) {
      const error = e as PostgrestError;
      console.error("Êõ¥Êñ∞ÂÄã‰∫∫Ë≥áÊñôÊôÇÁôºÁîüÈåØË™§:", JSON.stringify(error, null, 2));
      const errorMessage = error.message || "Êõ¥Êñ∞ÂÄã‰∫∫Ë≥áÊñôÊôÇÁôºÁîüÊú™È†êÊúüÁöÑÈåØË™§„ÄÇ";
      return { success: false, error: errorMessage };
    } finally {
      setIsUpdatingProfile(false);
    }
  };

  const deleteAccount = async (): Promise<{ error: string | null }> => {
    if (!user) {
       toast({ title: "ÈåØË™§", description: "‰ΩøÁî®ËÄÖÊú™ÁôªÂÖ•„ÄÇ", variant: "destructive" });
       return { error: "User not logged in" };
    }
    const { error } = await supabase.rpc('delete_user_account');
    if (error) {
      console.error('Error deleting account:', error);
      return { error: error.message };
    }
    return { error: null };
  };

  const sendPasswordResetEmail = async (email: string): Promise<{ error: string | null }> => {
    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email);
      if (error) throw error;
      return { error: null };
    } catch (error) {
      console.error("Error sending password reset email:", error);
      return { error: "ÁÑ°Ê≥ïÁôºÈÄÅÂØÜÁ¢ºÈáçË®≠ÈÉµ‰ª∂ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ" };
    }
  };

  const resendVerificationEmail = async (email: string): Promise<{ error: string | null }> => {
    try {
      const { error } = await supabase.auth.resend({
        type: 'signup',
        email: email,
        options: {
          emailRedirectTo: `${window.location.origin}/auth/callback`
        }
      });
      if (error) throw error;
      return { error: null };
    } catch (error) {
      console.error("Error resending verification email:", error);
      return { error: "ÁÑ°Ê≥ïÈáçÊñ∞ÁôºÈÄÅÈ©óË≠âÈÉµ‰ª∂ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ" };
    }
  };

  const updateUserEmail = async (newEmail: string): Promise<{ error: string | null }> => {
    if (!user) {
      return { error: "‰ΩøÁî®ËÄÖÊú™ÁôªÂÖ•„ÄÇ" };
    }
    try {
      const { error } = await supabase.auth.updateUser({ email: newEmail });
      if (error) throw error;
      return { error: null };
    } catch (error) {
      console.error("Error updating user email:", error);
      return { error: "ÁÑ°Ê≥ïÊõ¥Êñ∞ÈÉµ‰ª∂Âú∞ÂùÄÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ" };
    }
  };

  const value = {
    dogsToSwipe,
    likedDogs,
    seenDogIds,
    likeDog,
    passDog,
    getDogById,
    isLoadingDogs,
    loadDogsWhenNeeded,
    getLikedDogsCount,

    user,
    profile,
    session,
    isLoadingAuth,
    isUpdatingProfile,
    login,
    signUp,
    logout,
    updateProfile,
    deleteAccount,
    sendPasswordResetEmail,
    resendVerificationEmail,
    updateUserEmail,
  };

  return <PawsConnectContext.Provider value={value}>{children}</PawsConnectContext.Provider>;
};

export const usePawsConnect = () => {
  const context = React.useContext(PawsConnectContext);
  if (context === undefined) {
    throw new Error('usePawsConnect must be used within a PawsConnectProvider');
  }
  return context;
};




